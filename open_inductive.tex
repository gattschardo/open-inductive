\let\oldvec\vec% Store \vec in \oldvec
\documentclass{llncs}
\let\vec\oldvec% Restore \vec from \oldvec

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{microtype}
\usepackage{paralist}
\usepackage{hyperref}

\usepackage[safe]{tipa} % for \textlambda
\usepackage{amsmath}
\usepackage{mathpartir}

\urlstyle{sf}
\makeatletter
% Inspired by http://anti.teamidiot.de/nei/2009/09/latex_url_slash_spacingkerning/
% but slightly less kern and shorter underscore
\let\UrlSpecialsOld\UrlSpecials
\def\UrlSpecials{\UrlSpecialsOld\do\/{\Url@@slash}\do\_{\Url@@underscore}}%
\def\Url@@slash{\@@ifnextchar/{\kern-.11em\mathchar47\kern-.2em}%
   {\kern-.0em\mathchar47\kern-.08em\penalty\UrlBigBreakPenalty}}
\def\Url@@underscore{\nfss@@text{\leavevmode \kern.06em\vbox{\hrule\@@width.3em}}}
\makeatother


% For the launchbury stuff, copied from elsewhere
% Syntax
\newcommand{\sApp}[2]{#1\;#2}
\newcommand{\sLam}[2]{\text{\textlambda} #1.\, #2}
\newcommand{\sLet}[2]{\text{\textsf{let}}\ #1\ \text{\textsf{in}}\ #2}
\newcommand{\sred}[4]{#1 : #2 \Downarrow #3 : #4}
% 'DOWNWARDS TRIPLE ARROW' (U+290B)
\newcommand{\ssred}[4]{#1 : #2 \mathrel{\rotatebox[origin=c]{90}{$\Lleftarrow$}} #3 : #4}
\newcommand{\sRule}[1]{\text{{\textsc{#1}}}}
\newcommand{\dom}[1]{\mathsf{dom}\;#1}
\newcommand{\carrier}[1]{\mathsf{carrier}\;#1}


%\DeclareMathOperator*{\mywedge}{\!{\textstyle\bigwedge}\!}
\newcommand{\mywedge}{\mathop{\textstyle\bigwedge}}

% http://tex.stackexchange.com/a/2645/15107
\makeatletter
\newcommand{\nolisttopbreak}{\par\nobreak\@afterheading}
\makeatother


\usepackage{isabelle}
\usepackage{isabellesym}
% for uniform font size
%\renewcommand{\isastyle}{\isastyleminor}

% Isabelle snippets (https://isabelle.in.tum.de/community/Generate_TeX_Snippets)
\newcommand{\DefineSnippet}[2]{%
   \expandafter\newcommand\csname snippet--#1\endcsname{%
     %\begin{quote}
     \begin{isabelle}%
     #2
     \end{isabelle}%
     %\end{quote}
     }}
\newcommand{\Snippet}[1]{\csname snippet--#1\endcsname}
 
\input{snippets/snippets}


\title{Open Inductive Predicates}
\author{Joachim Breitner \and Richard Molitor}
\institute{Karlsruhe Institute of Technology}



\begin{document}

\maketitle

\begin{abstract}
Inductively defined predicates are inherently modular. This is regularly used in pen-and-paper proofs.

We present the theory of \emph{open inductive predicates} to make this often implicitly used modularity explicit, and demonstrate how to use it in interactive theorem provers (Isabelle/HOL in this case) as well.
\end{abstract}

\section{Introduction}

\begin{quote}
“In [42], Mueller et al. introduce the WizWoz abstract virtual machine, provide a natural semantics and prove, by induction on the rules of the semantics, that it is tenacious. In this work, we extend the semantics machine by a rule for categorical nonsensical shuffling. The extended WizWoz machine is still tenacious: We prove tenaciousness for the additional case; see [42] for the remaining cases.”
\end{quote}

Inductively defined predicates -- the bread and butter of many formal works, from programming languages semantics over types and logics to abstract algebra -- are inherently modular: If we add, remove or change one of the introduction rules the predicates was defined with, then in a proof by rule induction only the proof obligation of the corresponding case changes; the others stay the same.

This is often exploited in pen-and-paper-proofs that discuss several variants of, say, a natural semantics, or in papers that extend existing definitions with their own rules -- as in the hypothetical example above. The modularity of inductively defined predicates is so obvious that little fuzz is made about it.

Such convenience is not available to users of interactive theorem provers, as to the machine, two similarly defined inductive predicates are still different predicates, and “see the other proof” is not (yet) a admissible proof tactics. So one has no choice but to copy the common parts of the definitions and the proofs. One might then manually and tediously extract repeated proofs as lemmas of their own. In either case, maintaining such redundancy will cause headaches when further changes need to be made. Furthermore, this does not scale if many variants of one predicate are needed.

Our aim is to make such convenience as in the pen-and-paper proof available to the users of interactive theorem provers. In order to do so, we formalize the intuition behind these shortcuts and introduce the concept of \emph{open inductive predicates}. A theorem involving such an open predicate can be proven independently for each inductive case. Concrete instances for the predicate can be produced by specifying the actual set of introduction rules to be used, and all those theorems that have proofs for all used introduction rules are then automatically proved for the concrete instance.

\noindent Our contributions are\nolisttopbreak
\begin{itemize}
\item We introduce the theory of open inductive predicates to formalize the folklore around inductively defined predicate and their modularization.
\item We point out what such an inductive proof may assume about the predicate in order for the modularization to be sound.
\item We describe an implementation of open inductive predicates as a conservative extension to the interactive theorem prover Isabelle/HOL.
\end{itemize}

\section{The theory of open inductive predicates}

Despite the ubiquity of inductively defined predicates both in informal and formal mathematics, there is no canonical, abstract description of how such an predicate is defined and what the resulting artifacts (definitions, theorems) are, so we provide our own, inspired by \cite{paulson-2000}. This is not specific to a particular logic, so we try to present it in a mostly generic way. For example, these ideas are oblivious as to whether the logic is typed or not.

\subsection{From regular inductive predicates\ldots}

An inductive predicate $P_J$ is defined by specifying \emph{introduction rules}, which are formulas of the form
\[
I_i[P]:\ \forall \vec x.\,   M_i[P, \vec x] \implies P(t_i(\vec x)), \quad i \in J
\]
where $M_i$ is the premise of the rule, which may be absent (i.e.\ vacuously true), $t_i$ is an arbitrary term, and $\vec x$ are the free variables occurring in $M_i$ and $t_i$ the introduction rule. We only model unary predicates here; the generalization to relations is mostly technical.

Given such rules, and if certain side-conditions\footnote{These depend on the particular logic. For example, in the case of the implementation of inductive predicates in Isabelle/HOL via least fixedpoints, the $M_i$ need to be monotone.} hold, then the predicate $P_J$ is introduced to the logic, the introduction rules $I_n[P_J]$ become theorems for $P_J$ and, most importantly, the following induction rule for $P_J$ is a theorem in the logic:
\begin{mathpar}
\forall Q.\,
\inferrule{
\big[
\forall \vec x.\,
M_i[P_J\wedge Q, \vec x] \implies Q(t_i(\vec x))
\big]_{i\in J}
}
{\forall x.\, P_J(x) \implies Q(x)}
\end{mathpar}

We carefully distinguish between the variable $P$, as it occurs in terms such as $I_i[P]$, and the concrete inductive predicate $P_J$, which is formed from the inductive predicate $I_i$, $i\in J$.

\begin{example}
\label{ex:reach}
The two rules $I_1:\ P(a)$ and $I_2:\ \forall x\,y.\, P(x) \wedge R(x,y) \implies P(y)$ define the predicate „is reachable from $a$ by the relation $R$“ together with the induction rule
\begin{mathpar}
\forall Q.\,
\inferrule{
Q(a) \\ \forall x\,y.\,  P_{\{1,2\}}(x)\wedge Q(x) \wedge R(x,y) \implies Q(y)
}
{\forall x.\, P_{\{1,2\}}(x) \implies Q(x)}
\end{mathpar}

A proof of the proposition $\forall x.\, P_{\{1,2\}}(x) \implies x \in \carrier R$ using this induction rule would produce the two proof obligations
\begin{compactitem}
\item $a \in \carrier R$ and 
\item $\forall x\,y.\,  P_{\{1,2\}}(x)\wedge x\in \carrier R\wedge R(x,y) \implies y \in\carrier R$.
\end{compactitem}
\end{example}

Already this formulation makes the key observation motivating this work evident: For a given proposition $Q$ and inductive predicate $P_J$, the proof obligation for the inductive case $i\in J$ in an application of the induction theorem only depends on $M_i$ and $t_i$. Adding, removing or changing the other introduction rules has no effect on this.

\begin{example}
As a variation of \autoref{ex:reach}, consider the predicate „is reachable from $a$ by the symmetric closure of $R$“. In addition to $I_1$ and $I_2$ we would add the introduction rule $I_3:\ \forall x\,y.\, P(x) \wedge R(y,x) \implies P(y)$. Note that the assumptions in the induction rule
\begin{mathpar}
\forall Q.\,
\inferrule{
Q(a) \\ 
\forall x\,y.\,  P_{\{1,2,3\}}(x)\wedge Q(x) \wedge R(x,y) \implies Q(y) \\
\forall x\,y.\,  P_{\{1,2,3\}}(x)\wedge Q(x) \wedge R(y,x) \implies Q(y)
}
{\forall x.\, P_{\{1,2,3\}}(x) \implies Q(x)}
\end{mathpar}
are (besides the name of the inductive predicate) unchanged, and of the subgoals when proving $P_{\{1,2,3\}}(x) \implies x \in \carrier R$, namely
\begin{compactitem}
\item $a \in \carrier R$,
\item $\forall x\,y.\,  P_{\{1,2,3\}}(x)\wedge x\in \carrier R\wedge R(x,y) \implies y \in\carrier R$ and
\item $\forall x\,y.\,  P_{\{1,2,3\}}(x)\wedge x\in \carrier R\wedge R(y,x) \implies y \in\carrier R$,
\end{compactitem}
the first two are unmodified.
\end{example}

\subsection{\ldots to open inductive predicates}

Assume for a given proposition $Q$, the proof for such a proof obligation does not rely on any particular properties of $P_J$. Then we can state the corresponding proof obligation as an independent lemma:
\[
C_i[Q]:\ \forall P\, \vec x.\,   M_i[P \wedge Q, \vec x] \implies Q(t_i(\vec x))
\]
Note that in this \emph{partial inductive proof} the predicate $P$ is quantified over; the proof will know nothing about $P$.
%, not even the introduction rule $I_i[P_J]$ itself.
This allows us to state and prove this theorem independently of any concrete definition of $P_J$.
 
If we now introduce a concrete inductive predicate $P_J$ with introduction rules $I_i[P]$, $i\in J$, and we have proven $C_i[Q]$ for $i\in J$, then the proof of $P_J(x) \implies Q(x)$ is immediate: After applying the induction theorem, each subgoal $i\in J$ can be solved by specializing the corresponding partial inductive proof $C_i[Q]$ to the concrete predicate $P_J$:
\begin{mathpar}
\inferrule*[Right=induction]{
\big[
%{\forall i\in J.\,}
\inferrule*[Right=specialization]{
C_i[Q]
}{
\forall \vec x.\, M_i[P_J\wedge Q, \vec x] \implies Q(t_i(\vec x))
}
\big]_{i\in J}
}
{\forall x.\, P_J(x) \implies Q(x)}
\end{mathpar}

\noindent Applying this idea to our example, we would prove the three theorems 
\begin{compactitem}
\item $C_1: \forall P.\, a \in \carrier R$,
\item $C_2: \forall P.\, \forall x\,y.\,  P(x)\wedge x\in \carrier R\wedge R(x,y) \implies y \in\carrier R$ and
\item $C_3: \forall P.\, \forall x\,y.\,  P(x)\wedge x\in \carrier R\wedge R(y,x) \implies y \in\carrier R$,
\end{compactitem}
once and obtain $P_J(x) \implies x \in \carrier R$ for any of the two inductive definitions (i.e.\ $J=\{1,2\}$ and $J=\{1,2,3\}$), without having to repeat the proofs.


\subsection{The Introduction rule as an assumption}

In the previous section, the proof for the inductive cases of $P_J(x) \implies Q(x)$ did not make any assumption about $P_J$ itself. Often, that is too restrictive, e.g. when the $P_J$ occurs in $Q$, such as in the proposition $P_J(x) \implies P(f(x))$ for some function $f$.
In order to extract each inductive case as a separate lemma abstract in $P$, we have to include additional assumptions about $P$ to it. In this case, it suffices to add the introduction rule corresponding to the current case under $P$-quantifier:
\[
C_i[Q]:\ \forall P.\, I_i[P] \implies \forall \vec x.\,   M_i[P \wedge Q, \vec x] \implies Q(t_i(\vec x))
\]

When we use such a partial inductive proof obligation in an inductive proof, we not only specialize it, but discharge the assumption using the real introduction rule (which, by then, is a theorem):

\begin{mathpar}
\inferrule*[Right=induction]{
\big[
%{\forall i\in J.\,}
\inferrule*[Right=MP]{
I_i[P_J] \\
\inferrule*[Right=specialization]{
C_i[Q]
}{
I_i[P_J] \implies \forall \vec x.\, M_i[P_J\wedge Q, \vec x] \implies Q(t_i(\vec x))
}
}
{
\forall \vec x.\, M_i[P_J\wedge Q, \vec x] \implies Q(t_i(\vec x))
}
\big]_{i\in J}
}
{\forall x.\, P_J(x) \implies Q(x)}
\end{mathpar}

In our example, the partial proof obligations would be
\begin{compactitem}
\item $C_1': \forall P.\, P(a) \implies P(f(a))$,
\item
\begin{tabbing}
$C_2': \forall P.\, $\=$(\forall x\,y.\,  P(x) \wedge R(x,y) \implies P(y)) \implies$\\
\>$\forall x\,y.\,  P(x)\wedge P(f(x)) \wedge R(x,y) \implies P(f(y))$ and
\end{tabbing}
\item
\begin{tabbing}
$C_3': \forall P.\, $\=$(\forall x\,y.\,  P(x) \wedge R(y,x) \implies P(y)) \implies$\\
\>$\forall x\,y.\,  P(x)\wedge P(f(x)) \wedge R(y,x) \implies P(f(y))$,
\end{tabbing}
\end{compactitem}
which are provable for a $f$ with, say, $f(a) = a$ and $R(x,y) \implies R(f(x), f(y))$).

\subsection{More introduction rules as assumptions}

The additional assumption in the previous does not pose a restriction on what inductive theorems will hold for an inductive predicate $P_J$: Whenever $C_i[Q]$ is proven for all $i\in J$, then $\forall x.\, P_J(x) \implies Q_J$ holds.

This changes if we have to use other introduction rules as well. If the proof for the inductive case $i\in J$ requires the introduction rules $I_j[P]$ for $j \in J_i$, we need to provide all of these as assumptions in the partial inductive proofs:
\[
C_i[Q]:\ \forall P.\, (\mywedge_{j\in J_i} I_j[P]) \implies \forall \vec x.\,   M_i[P \wedge Q, \vec x] \implies Q(t_i(\vec x))
\]

Again, we want to discharge these assumptions before using $C_i[Q]$ in a proof for $\forall x.\, P_J(x) \implies Q(x)$:
\begin{mathpar}
\inferrule*[Right=induction]{
\big[
%{\forall i\in J.\,}
\inferrule*[Right=MP]{
%\mywedge_{j \in J_i}
\big[
I_j[P_J]
\big]_{j\in J_i}
\\
\inferrule*[Right=specialization]{
C_i[Q]
}{
(\mywedge_{j \in J_i} I_j[P_J]) \implies
\cdots
%\forall \vec x.\, M_i[P_J\wedge Q, \vec x] \implies Q(t_i(\vec x))
}
}
{
\forall \vec x.\, M_i[P_J\wedge Q, \vec x] \implies Q(t_i(\vec x))
}
\big]_{i\in J}
}
{\forall x.\, P_J(x) \implies Q(x)}
\end{mathpar}

This derivation is only valid if all used introduction rules are actually available, i.e.\ $J_i \subseteq J$ for all $i\in J$.  The previous section is a special case with $J_i=\{i\}$, where that condition holds always.


Example: TODO

\subsection{Extensions and limits}

There are inductive proofs that use more properties of the inductive predicate that just the induction rules. One would, for example, like to use other theorems in a similar manner. And certainly that is possible: Just add $(\forall x.\, P(x) \implies Q'(x))$ as an additional assumption under the $P$-quantifier in the proposition $C_i[Q]$. When constructing the proof for $(\forall x.\, P_J(x) \implies Q(x))$, we discharge that assumption with the theorem $(\forall x.\, P_J(x) \implies Q'(x))$, which we have to prove first -- obviously cycles are not permitted here.

There are limits to how far this modularization can be applied. A particular good example for that are determinism proofs of the form $P(x,y) \implies P(x,z) \implies y = z$. The usual proof would first apply the induction theorem on the first assumption, and then, in each inductive step, apply rule inversion on the second assumption. But as the rule inversion theorem produces one subgoal per introduction rule, the premise of the modularization is violated: If one introduction rule is changed, this change will affect the proof of \emph{all} inductive cases. 


\section{Open inductive predicates in Isabelle}

So far we have merely cast something quite obvious into formulas, hinting at the bookkeeping required to correctly modularize inductive proofs. In pen-and-paper proofs, the bookkeeping is done implicit and intuitively right. But for formalized proofs, appeals to intuition are unfortunately not yet possible. Therefore, we (conservatively) extended Isabelle to do the bookkeeping required for open inductive predicates for us.

Continuing from the example, let us first review the declaration of the inductive predicates $P_{\{1,2\}}$ and $P_{\{1,2,3\}}$ in Isabelle:
\Snippet{inductive1}
\Snippet{inductive2}

The inductive proof of the theorem $P_{\{1,2\}}(x) \implies x\in \carrier R$ has two cases, as expected:
\Snippet{proof1}

And the corresponding proof for $P_{\{1,2,3\}}(x)$ has three, two of which are -- up to the name of the predicate -- identical:
\Snippet{proof2}

When using our support for open inductive predicates, the declaration of the predicate is modularized: We first declare the signature of the predicate, and specify the first two introduction rules, giving names to them:
\Snippet{open_inductive}
\Snippet{add_intros}

At this point, nothing has been added to the logic yet. This is done when we close the predicate, specifying the concrete induction rules and a name:
\Snippet{close_inductive}

In order to modularize the proof of a theorem involving an open inductive predicate, we declare it first:
\Snippet{open_theorem}
The proofs for each case is performed separately, and stored as a theorem on its own:
\Snippet{show_open}

As we have proven the open theorem for all cases, it automatically becomes a theorem for the concrete \isa{P\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{2}}{\isacharprime}}.

We can now proceed to declare a new introduction rule:
\Snippet{add_intros2}

Again, this does not affect the logic, until we demand a concrete predicate to be defined:
\Snippet{close_inductive2}

At this point, the machinery does not yet proof our open theorem for  \isa{P\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{2}}\isactrlsub {\isadigit{3}}{\isacharprime}}, as the proof would not go through, as it we have not provided the proof for the \isa{backwards} case yet. We could have done that before closing the predicate, but we can just as well do it now
\Snippet{show_open2}

Using the five commands provided by the open inductive package, we have defined the same predicates and proven the same theorems as in the example before, but we did not have to repeat the introduction rules nor the proofs when we introduced the variant.








\section{Conclusion}

\subsubsection*{Acknowledgments}

\bibliographystyle{splncs03}
\bibliography{bib}
\end{document}
